.syntax unified

.global pulse_buffer
.global buffer_pos

/*
 ASM generated by gcc,
 cleaned up with symbol names substituted
 back in and comments added to tie to C code,
 then hand optimized from ~32 ops -> ~14 ops

void TIMER0_IRQHandler2(void) {
 pulse_buffer[buffer_pos] = LPC_TIM0 ->IR;
 LPC_TIM0 ->IR = 0xff;

 // truncate buffer_pos to 10bits
 buffer_pos = (buffer_pos + 1) & (BUFFER_LEN - 1);
}

*/
.global TIMER0_IRQHandler
TIMER0_IRQHandler:
// ARM stack frame explanation:
// http://msdn.microsoft.com/en-us/library/aa448593.aspx

// setup stack frame (skipped, we don't use the stack at all)
// push {r7}
// add r7, sp, #0

// r3 = buffer_pos
   ldr r3, =buffer_pos
   ldr r3, [r3, #0]

  // r2 = &(LPC_TIM0->IR)
  // r1 = &r2
   mov.w r2, #0x40004000 // Read LPC_TIM0->IR from memory
   ldr r1, [r2, #0]

  // pulse_buffer[buffer_pos] = LPC_TIM0->IR
   ldr r2, =pulse_buffer
   str.w r1, [r2, r3, lsl #2] // *(r2 + (r3 << 2)) = r1

  // LPC_TIM0->IR = 0xFF
   mov r1, #0xFF
   str r1, [r2, #0]

  // buffer_pos = (buffer_pos + 1) & (2^10 - 1)
   addw r3, r3, #1
  // Shift left 22 bits and then right to simulate AND
   mov.w r3, r3, lsl #22
   mov.w r3, r3, lsr #22

   // r2 = buffer_pos
   ldr r2, =buffer_pos
   str r3, [r2, #0]

  // Unwind stack and return
  // mov sp, r7
  // pop {r7}
   bx lr
